---
title: "01.RAD21_HiC_analyses_visualization.Rmd"
author: "Wenxue Zhao"
date: '2023-03-07'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Overview
This R markdown contains the scripts used to generate Hi-C statistic figures in our work. All the sequencing data have been upload to GEO under accession number GSE183186 (https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE183186). We also upload HiC matrix data as processed results that can be download from GEO. The processed input data used in this scripts were generated by HiC-Pro:
 - ".allValidPairs" files containing contact pairs. 
 - ".dis_int" files extracted chromosome distance and interaction pairs from ".allValidPairs" using a custom python  script.
 - "_abs.bed" files contain the chromatin bin information.
 - "_dense_iced.matrix" files were generated from "_iced.matrix" using sparseToDense.py provided by HiC-Pro.

# Environment Requirement
```{R environment}
utils::sessionInfo()

# R version 3.6.0 (2019-04-26)
# Platform: x86_64-redhat-linux-gnu (64-bit)
# Running under: CentOS Linux 7 (Core)
# 
# Matrix products: default
# BLAS/LAPACK: /usr/lib64/R/lib/libRblas.so
# 
# Random number generation:
#  RNG:     Mersenne-Twister 
#  Normal:  Inversion 
#  Sample:  Rounding 
#  
# locale:
#  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               LC_TIME=en_US.UTF-8       
#  [4] LC_COLLATE=en_US.UTF-8     LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
#  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  LC_ADDRESS=C              
# [10] LC_TELEPHONE=C             LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
# 
# attached base packages:
# [1] stats4    parallel  stats     graphics  grDevices utils     datasets  methods   base     
# 
# other attached packages:
#  [1] pheatmap_1.0.12                         GENOVA_1.0.0                           
#  [3] ggnewscale_0.4.8                        multiHiCcompare_1.4.0                  
#  [5] BSgenome.Hsapiens.UCSC.hg19_1.4.0       BSgenome_1.54.0                        
#  [7] rtracklayer_1.46.0                      RColorBrewer_1.1-2                     
#  [9] GenomicAlignments_1.22.1                Rsamtools_2.2.3                        
# [11] Biostrings_2.54.0                       XVector_0.26.0                         
# [13] SummarizedExperiment_1.16.1             DelayedArray_0.12.3                    
# [15] BiocParallel_1.20.1                     matrixStats_0.59.0                     
# [17] dplyr_1.0.7                             data.table_1.14.0                      
# [19] TxDb.Hsapiens.UCSC.hg19.knownGene_3.2.2 GenomicFeatures_1.38.2                 
# [21] AnnotationDbi_1.48.0                    Biobase_2.46.0                         
# [23] rmarkdown_2.19                          HiTC_1.30.0                            
# [25] GenomicRanges_1.38.0                    GenomeInfoDb_1.22.1                    
# [27] IRanges_2.20.2                          S4Vectors_0.24.4                       
# [29] BiocGenerics_0.32.0                     reshape_0.8.8                          
# [31] reshape2_1.4.4                          MASS_7.3-54                            
# [33] ggplot2_3.3.5 

```

# R Functions
This chunk collects all the R functions used in this scripts. Some of functions are coded by the author, and the others are modified from published analyses that listed in the **Reference**. Thanks for their wisdom ideas! 
```{R functions}
# Function for calculate TAD score--------------------------------------------------------------------
# input1: hi-c matrix
# input2: crane TAD boundary files
# output: TAD score for each TAD

TADScore <- function(hic_matrix, TAD_boundaries, chr = "chr", resolution = 40000) {
  hic_matrix <- as.matrix(hic_matrix)
  total_bins <- dim(hic_matrix)[1]
  boundary_num <- dim(TAD_boundaries)[1]
  # define a TAD
  TAD_start <- TAD_boundaries$binEnd[-boundary_num] +1 
  TAD_end <- TAD_boundaries$binStart[-1]
  IntraTAD <- function(hic_matrix, start_bin, end_bin) {
    sub_TAD_Matrix <- hic_matrix[start_bin:end_bin, start_bin:end_bin]
    IntraTAD <- sum(sub_TAD_Matrix, na.rm = T) + sum(diag(sub_TAD_Matrix), na.rm = T)
    return(IntraTAD/2)
  }
  
  TAD_score <- numeric()
  for ( i in 1:length(TAD_start)) {
    intra_TAD_interactions <- IntraTAD(hic_matrix, start_bin = TAD_start[i], end_bin = TAD_end[i])
    for (j in 1:length(TAD_start)) {
      interTAD[i] <- sum(hic_matrix[TAD_start[i]:TAD_end[i], TAD_start[j]:TAD_end[j]], na.rm = T)
      inter_TAD_interactions <- sum(interTAD[i])
    }
    TAD_score <- c(TAD_score, (inter_TAD_interactions-intra_TAD_interactions)/intra_TAD_interactions)
  }
  output_bed <- cbind(chr = chr, chr_start = (TAD_start - 1) * resolution, chr_end = TAD_end * resolution, TAD_score = TAD_score)
  return(output_bed)
}

# TAD insulation score -----------------------------------------------------------------------------
# input1: insulation.bedGraph
# input2: boundaries.bed
# output: TAD boundary insulation score

LocalIS <- function( bed_vec, insulation_score, flank = 25) {
  resolution <- 40000
  # add 0 data to the head and end of the table to avoid border problem
  tmp_0 <- matrix(NA, nrow = flank, ncol = dim(insulation_score)[2] )
  tmp_ins_matrix <- rbind(tmp_0, as.matrix(insulation_score), tmp_0)   # merge all insulation.bed of each chromosome
  # find the region id of input region in insulation_score + and - flank
  start_neibour_id <- floor(as.numeric(bed_vec[2]) / resolution) + 1 + flank
  start_neibour_insulation_score <- tmp_ins_matrix[(start_neibour_id - flank):(start_neibour_id + flank), 4]
  return( start_neibour_insulation_score )
}

# R function to extract trans interaction ------------------------------------------------
# input: Hi-C dense matrix
# output: a list containing trans interaction matrix

trans_matrix <- function(full_dense_matrix, prefix){
  chr.index <- 1:23
  print(paste0("dim(matrix)[1]==sum(bin.num): ", identical(as.numeric(dim(full_dense_matrix)[1]),sum(bin.num))))
  
  chr.matrix <- list()
  for (i in chr.index){
    chr.matrix[[i]] <- list()
    i_start <- c(1,bin.index[-23]+1)[i]
    i_end <- bin.index[i]
    for (j in chr.index[which(chr.index==i):23]){
      j_start <- c(1,bin.index[-23]+1)[j]
      j_end <- bin.index[j]
      chr.matrix[[i]][[j]] <- full_dense_matrix[i_start:i_end,j_start:j_end]
      print(paste0(prefix,"_",i,"_",j," done!"))
    }
  }
  return(chr.matrix)
}

# R function to calculate the sum of upper-triangular interaction of a Hi-C matrix ----------------------------
# input: a list containing trans interaction matrix
# output: a list containing trans interaction matrix

UpperTriSum <- function ( HiC_matrix) {
  if ( is.null(HiC_matrix)) {
    return(0)
  }
  else 
    return( sum(HiC_matrix[upper.tri(HiC_matrix, diag = T) ] ) )
}


# R function to calculate the sum of trans interaction of a Hi-C upper-triangular matrix -----------
# input: a list containing trans interaction matrix
# output: a matrix containing the sum of trans interaction of each chromosome.

chr.index <- 1:23
trans_sum <- function(chr.matrix){
  trans_sta <- list()
  for (i in chr.index){
    trans_sta[[i]] <- list()
    for (j in chr.index){
      if (i==j)
        trans_sta[[i]][[j]] <- UpperTriSum(chr.matrix[[i]][[j]])
      else {
        if (i < j)
          trans_sta[[i]][[j]] <- sum(chr.matrix[[i]][[j]])
        else
          trans_sta[[i]][[j]] <- trans_sta[[j]][[i]]
      }
    }
  }
  trans_sum <-  matrix(unlist(trans_sta),nrow = 23)
  return(trans_sum)
}

```

# Fig4A 
Hi-C interaction frequency as a function of logarithmically increasing genomic distance bins for cells with and without RAD21 over-expression.

```{r Fig4A.Hi-C_interaction_frequency_as_a_function_of_genomic_linear_distance}
# load ".dis_int" files, containing chromosome distance and interaction pairs
WT_dis_act = read.table("/data/distance_interaction/WT.dis_int", stringsAsFactors = F, row.names = 1)
OE_dis_act = read.table("/data/distance_interaction/OE.dis_int", stringsAsFactors = F, row.names = 1)

# normalize the contact interaction to make it comparable between WT and RAD21-OE
WT_dis_act$V2 = WT_dis_act$V2 / sum(WT_dis_act$V2) * sum(OE_dis_act$V2)

mat = as.matrix(cbind(WT_dis_act, OE_dis_act))
colnames(mat) = c("WT", "OE")
mat.m = melt(mat)
colnames(mat.m) = c("distance", "sample", "interaction")

ggplot(mat.m,aes(x=log10(distance)+3, y=log10(interaction), group = sample, color=sample)) +
  xlim(5,8)+
  geom_vline(xintercept = log10(3e5), linetype="dashed")+
  geom_vline(xintercept = log10(6e6), linetype="dashed")+
  scale_colour_manual(values = c("black","red")) +
  stat_smooth(method = 'loess', span = 0.1, se = FALSE, level = 0.95)+
  labs(x="Distance",y="contact probability")+
  theme_classic()

```

# Fig4D
Ratios of inter-compartment interactions (AB) and intra-compartment interactions (AA+BB) for each chromosome (X chromosome excluded) in control and RAD21-OE cells (***P < 0.001, wilcoxon.test). 

```{r Fig4D	Ratios of inter-compartment interactions (AB) and intra-compartment interactions (AA+BB) for each chromosome (X chromosome excluded) in control and RAD21-OE cells}
# load abs.bed generated by HiC-Pro, containing the chromatin bin information needed by PC1 calculation.
xgi.bed = "/hic_results/matrix/OE/raw/150000/OE_150000_abs.bed"
ygi.bed = "/hic_results/matrix/OE/raw/150000/OE_150000_abs.bed"

# load matrix after ICE normalization on contact maps
WT <- importC("/hic_results/matrix/WT/iced/150000/WT_150000_iced.matrix",
              xgi=xgi.bed, ygi=ygi.bed, rm.trans = T)
OE <- importC("/hic_results/matrix/OE/iced/150000/OE_150000_iced.matrix",
               xgi=xgi.bed, ygi=ygi.bed, rm.trans = T)

rm(xgi.bed, ygi.bed)
seqlevels(WT)

# Read in annotation databases generated from UCSC to get gene 
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
gene.hg19 <- genes(txdb)
rm(txdb)

# calculate PC1 value for each bin and defined A and B compartment according to gene density, since HiTC package may cause reverse results when producing PCA results. A compartment usually has higher gene density than B compartment.
for (i in c("WT","OE")){ 
  assign(paste0("AB.",i), data.frame())
  for (j in 1:23){
    pc <- pca.hic(get(i)[[j]], normPerExpected=TRUE, method="mean", npc=1, gene.gr = gene.hg19) # we use mean method here, since HiTC recommends that this method works for all resolutions. While Lowess regression model and works usually fine with low resolution data (250Kb to 1Mb). We have also used another method and the results were similar.
    assign(paste0("AB.",i), rbind(get(paste0("AB.",i)), as.data.frame(pc)[,c(3:5,8:10)]))
  }
}

rm(gene.hg19, i, j, pc)
rm("WT","OE")

# calculate inter-compartment contact ratio for each chromosome.
res.WT <- c() 
for (i in paste0("chr",c(1:22))) # the calculation excluding chrX
{
  tmp.AB.WT <- AB.WT[AB.WT$seqnames==i,]
  row.names(tmp.AB.WT) <- NULL
  tmp.mat.WT <- as.matrix(read.table(paste0(i,"_WT_150000_iced_dense.matrix"))) # read in dense matrix of each chromosome
  tmp.A.WT <- which(tmp.AB.WT$ccompartments=="A")
  tmp.B.WT <- which(tmp.AB.WT$ccompartments=="B")
  tmp.sort.WT <- tmp.mat.WT[c(tmp.A.WT,tmp.B.WT),c(tmp.A.WT,tmp.B.WT)]
  tmp.WT.AA <- sum(tmp.sort.WT[upper.tri(tmp.sort.WT[1:length(tmp.A.WT),1:length(tmp.A.WT)],diag=F)])
  tmp.WT.BB <- sum(tmp.sort.WT[upper.tri(tmp.sort.WT[(length(tmp.A.WT)+1):(length(tmp.A.WT)+length(tmp.B.WT)),(length(tmp.A.WT)+1):(length(tmp.A.WT)+length(tmp.B.WT))],diag=F)])
  tmp.WT.AB <- sum(tmp.sort.WT[1:length(tmp.A.WT),(length(tmp.A.WT)+1):(length(tmp.A.WT)+length(tmp.B.WT))])
  chr.res.WT <- tmp.WT.AB/(tmp.WT.AA+tmp.WT.BB)
  
  res.WT <- c(res.WT,chr.res.WT)
}


res.OE <- c()
for (i in paste0("chr",c(1:22)))
{
  tmp.AB.OE <- AB.OE[AB.OE$seqnames==i,]
  row.names(tmp.AB.OE) <- NULL
  tmp.mat.OE <- as.matrix(read.table(paste0(i,"_OE_150000_dense_iced.matrix"))) # read in dense matrix of each chromosome
  tmp.A.OE <- which(tmp.AB.OE$ccompartments=="A")
  tmp.B.OE <- which(tmp.AB.OE$ccompartments=="B")
  tmp.sort.OE <- tmp.mat.OE[c(tmp.A.OE,tmp.B.OE),c(tmp.A.OE,tmp.B.OE)]
  tmp.OE.AA <- sum(tmp.sort.OE[upper.tri(tmp.sort.OE[1:length(tmp.A.OE),1:length(tmp.A.OE)],diag=FALSE)])
  tmp.OE.BB <- sum(tmp.sort.OE[upper.tri(tmp.sort.OE[(length(tmp.A.OE)+1):(length(tmp.A.OE)+length(tmp.B.OE)),(length(tmp.A.OE)+1):(length(tmp.A.OE)+length(tmp.B.OE))],diag=FALSE)])
  tmp.OE.AB <- sum(tmp.sort.OE[1:length(tmp.A.OE),(length(tmp.A.OE)+1):(length(tmp.A.OE)+length(tmp.B.OE))])
  chr.res.OE <- tmp.OE.AB/(tmp.OE.AA+tmp.OE.BB)
  
  res.OE <- c(res.OE,chr.res.OE)
}

res.m <- melt(res)

# box plot
ggplot(res.m, aes(x = X2, y = value)) + 
  geom_boxplot(aes(fill=X2), outlier.size = 0,outlier.shape = NA, width = 0.6)+
  stat_boxplot(geom = "errorbar", width=0.35) + 
  geom_boxplot(aes(x = X2, y = value, fill=factor(X2)), color="black", outlier.size = 0, width = 0.6) + # outlier.shape = NA
  ylim(0.05,0.16)+
  labs(x = " ", y = "AB/(AA+BB)", title = "inter-compartment contact ratio")+
  scale_fill_manual(values = c("red","grey"))+
  theme_classic()+
  theme(axis.text.x = element_text(size = 16), 
        axis.text.y = element_text(size = 16),
        axis.title.y = element_text(size = 16))+
  geom_segment(aes(x=1, y=0.15, xend=2, yend=0.15))+ 
  geom_text(x=1.5, y=0.15, label="***", size= 6 )  # wilcox.test p value < 0.0006

```

# Fig4K
Contact frequency ratio of intra-TAD and inter-TAD (TAD score) (***P < 0.001, paired t-test).
### step_01 call TAD insulation score calculation 
This step was completed using matrix2insulation.pl published by cworld-dekker lab, the shell script was named "02.RAD21_HiC_call_TAD_InsulationScore.sh"
```{TAD score calculation}
run bash script in shell
```

### step_02 read in matrix and boundary file
```{TAD score calculation}
# wt
wt <- "WT"
TAD_score <- list()
for (i in wt) {
  TAD_score[[i]] <- numeric()
  TAD_boundary <- list()
  
  for (j in c(1:22, "X")) {
    # read hi-c matrix
    tmp_hic_file_name <- paste0("/TAD_analysis/TAD_40k/", i, "/chr", j, "_dense.matrix")
    hic_matrix <- read.table(file = tmp_hic_file_name )
    # read TAD boundary file
    tmp_TAD_boundary_file_name <- paste0("/TAD_analysis/TAD_40k/", i, "/chr", j, 
                                         "_dense.matrix--is520001--nt0--ids240001--ss160001--immean.insulation.boundaries")
    TAD_boundary[[j]] <- read.table(file = tmp_TAD_boundary_file_name, header = T)
    # calculate TAD score
    tmp_TAD_score <- TADScore(hic_matrix, TAD_boundary[[j]], chr = paste0("chr", j))
    TAD_score[[i]] <- rbind(TAD_score[[i]], tmp_TAD_score)
    print(paste0("Done with chr", j, " in sample ", i))
  }
  file_name <- paste0("/TAD_analysis/TADscore/", i, "_TAD_score.new.bed")
  write.table(x = TAD_score[[i]], file = file_name, sep = "\t", quote = F, row.names = F)
}

# OE
OE <- c("OE")
for (i in OE) {
  TAD_score[[i]] <- numeric()
  TAD_boundary <- list()
  
  for (j in c(1:22, "X")) {
    # read hi-c matrix
    tmp_hic_file_name <- paste0("/TAD_analysis/TAD_40k/", i, "/chr", j, "_dense.matrix")
    hic_matrix <- read.table(file = tmp_hic_file_name )
    # read TAD boundary file
    tmp_TAD_boundary_file_name <- paste0("/TAD_analysis/TAD_40k/", i, "/chr", j, 
                                         "_dense.matrix--is520001--nt0--ids240001--ss160001--immean.insulation.boundaries")
    TAD_boundary[[j]] <- read.table(file = tmp_TAD_boundary_file_name, header = T)
    # calculate TAD score
    tmp_TAD_score <- TADScore(hic_matrix, TAD_boundary[[j]], chr = paste0("chr", j))
    TAD_score[[i]] <- rbind(TAD_score[[i]], tmp_TAD_score)
    print(paste0("Done with chr", j, " in sample ", i))
  }
  file_name <- paste0("/TAD_analysis/TADscore/", i, "_TAD_score.new.bed")
  write.table(x = TAD_score[[i]], file = file_name, sep = "\t", quote = F, row.names = F)
}



```

### step_03 check data
```{TAD score calculation}
TAD_score_merge <- TAD_score
a <- ls()
rm(list=a[which(a!="TAD_score_merge")])
rm(a)

length(TAD_score_merge)
names(TAD_score_merge)

# plot TAD length density -------------------------------------
TAD_wt <- TAD_score_merge[[1]]
TAD_length_wt <- as.numeric(TAD_wt[,3])-as.numeric(TAD_wt[,2])

plot(density(TAD_length_wt),xlim=c(0,2e6))

quantile(TAD_length_wt)

```

### step_04 filter TAD length (if needed to do so)
refering to "Condensin-driven remodelling of X chromosome topology during dosage compensation"
```{TAD score calculation}
sample_name <- c("WT", "OE") 
TAD_score_filter_500k <- list()
for (i in sample_name){
  tmp <- TAD_score_merge[[i]]
  TAD_score_filter_500k[[i]] <- tmp[(as.numeric(tmp[,3])-as.numeric(tmp[,2])) > 5e5,]
  TAD_score_filter_500k[[i]] <- cbind(TAD_score_filter_500k[[i]],TAD_length=as.numeric(TAD_score_filter_500k[[i]][,3])-as.numeric(TAD_score_filter_500k[[i]][,2]))
  file_name <- paste0("/TAD_analysis/TADscore/filter_500k_", i, "_TAD_score.bed")
  write.table(x = TAD_score_filter_500k[[i]], file = file_name, sep = "\t", quote = F, row.names = F)
  print(paste0("Sample ",i," kept ",nrow(TAD_score_filter_500k[[i]]),"/",nrow(tmp),", done!" ))
}


View(TAD_score_merge_filter_500k[[1]])
names(TAD_score_merge_filter_500k) # "WT_merge" "OE_merge"

```

### step_05 plot
```{TAD score calculation}
box.wt <- as.numeric(TAD_score_merge[[1]][,4])
box.oe <- as.numeric(TAD_score_merge[[2]][,4])

par(mar=c(5,6,2,4),cex = 1.5, lwd = 2, xpd = F)
boxplot(box.wt,box.oe,
        main = " ",
        ylab = "TAD score",
        xlab = "WT OE",
        pch = " ",
        ylim = c(0.1,0.6),
        col = c(rgb(212,212,212,maxColorValue = 255,alpha = 100),
                rgb(253,13,27,maxColorValue = 255,alpha = 100)),
        border = c(rgb(0,0,0,maxColorValue = 255,alpha = 250),
                   rgb(253,13,27,maxColorValue = 255,alpha = 250)),
        boxwex = 0.6
)

```

# FigS4B & FigS4C
FigS4B: Distribution of TAD length in control and RAD21-OE cells. 
FigS4C: The number of short (< 500 kb) and long (> 500 kb) TADs.

### step_01 distribution of TAD length in all samples
```{TAD length distribution}
sample_name <- c("WT", "OE") 

TAD_length <- list()
for (i in sample_name) {
  TAD_length[[i]] <- as.numeric(TAD_score_merge_filter_200k[[i]][,5])
}

tmp_ytop <- 0
for ( i in 1:2) {
  tmp_ytop <- max( tmp_ytop, density(TAD_length[[i]])$y )
}

```

### step_02 line plot
```{TAD length distribution}

par(cex = 1.5, lwd = 3, xpd = F)
plot( density(TAD_length[[1]]/1000), type = "l", 
      lty = 1,
      ylim = c(0,0.002),
      xlim = c(0,2200),
      xlab = "TAD length (kb)", ylab = "Density",
      main = " ")

lines(density(TAD_length[[2]]/1000), col = rgb(253,13,27,maxColorValue = 255,alpha = 250), lty = 1)

legend("topright", col = c("black",
                           rgb(253,13,27,maxColorValue = 255,alpha = 250),
                           rgb(6,24,189,maxColorValue = 255,alpha = 250)),lty = 1,
       legend = paste(c("WT","OE")), bty = "n",cex = 0.8)
dev.off()
boxplot(TAD_length,ylim=c(0,1.8e6))

```

### step_03 statistic for TAD smaller than 500kb and larger than 500kb in each chromosome
referring to the methods in publications studying the WAPL-depletion (Haarhuis et al., 2017; Wutz et al., 2017).

```{TAD number statistic}
TAD_number <- list()
for (i in sample_name) {
  TAD_number[[i]] <- dim(TAD_score_merge_filter_200k[[i]])[1]
}

## statistic for TAD smaller than 500kb in each chromosome
small_TAD_500k <- list()
for (i in sample_name) {
  small_TAD_500k[[i]] <- c()
  small_TAD_500k[[i]] <- TAD_score_merge_filter_200k[[i]][as.numeric(TAD_score_merge_filter_200k[[i]][,5])<5e5,]
}

small_TAD_num_500k <- list()
for (i in sample_name) {
  small_TAD_num_500k[[i]] <- c()
  for (j in paste0("chr",c(1:22,"X")))
    small_TAD_num_500k[[i]] <- c(small_TAD_num_500k[[i]],length(small_TAD_500k[[i]][small_TAD_500k[[i]][,1]==j,]))
}

small_TAD_num_500k_chr.df <- as.data.frame(as.vector(small_TAD_num_500k))
small_TAD_num_500k_chr.m <- melt(small_TAD_num_500k_chr.df)

ggplot(small_TAD_num_500k_chr.m, aes(variable, value, fill = variable))+
  geom_boxplot() +
  stat_boxplot(geom = "errorbar", width=0.4) +
  geom_boxplot()+
  theme_classic(base_size = 13) + xlab("") + ylab("TAD number") +
  scale_fill_manual( values = c("grey","#ef3b2c"))

wilcox.test(small_TAD_num_500k_chr.df$WT, small_TAD_num_500k_chr.df$OE) # not significant

## statistic for TAD larger than 500kb in each chromosome
large_TAD_500k <- list()
for (i in sample_name) {
  large_TAD_500k[[i]] <- c()
  large_TAD_500k[[i]] <- TAD_score_merge_filter_200k[[i]][as.numeric(TAD_score_merge_filter_200k[[i]][,5]) >= 5e5,]
}

large_TAD_num_500k <- list()
for (i in sample_name) {
  large_TAD_num_500k[[i]] <- c()
  for (j in paste0("chr",c(1:22,"X")))
    large_TAD_num_500k[[i]] <- c(large_TAD_num_500k[[i]],length(large_TAD_500k[[i]][large_TAD_500k[[i]][,1]==j,]))
}

large_TAD_num_500k_chr.df <- as.data.frame(as.vector(large_TAD_num_500k))
large_TAD_num_500k_chr.m <- melt(large_TAD_num_500k_chr.df)

ggplot(large_TAD_num_500k_chr.m, aes(variable, value, fill = variable))+
  geom_boxplot() +
  stat_boxplot(geom = "errorbar", width=0.4) +
  geom_boxplot()+
  theme_classic(base_size = 13) + xlab("") + ylab("TAD number") +
  scale_fill_manual( values = c("grey","#ef3b2c"))

wilcox.test(large_TAD_num_500k_chr.df$WT_merge, large_TAD_num_500k_chr.df$OE_merge) # not significant

```

### step_04 stack barplot
```{TAD number statistic}

small_TAD_500k <- list()
for (i in sample_name) {
  small_TAD_500k[[i]] <- length(TAD_length[[i]][TAD_length[[i]]<5e5])
}

large_TAD_500k <- list()
for (i in sample_name) {
  large_TAD_500k[[i]] <- length(TAD_length[[i]][TAD_length[[i]]>5e5])
}

small_TAD_500k.df <- as.data.frame(as.vector(small_TAD_500k))
large_TAD_500k.df <- as.data.frame(as.vector(large_TAD_500k))

TAD_num_class <- data.frame(type = c("WT", "Rad21-OE"),
                              small = c(small_TAD_500k.df$WT, small_TAD_500k.df$OE),
                              large = c(large_TAD_500k.df$WT, large_TAD_500k.df$OE))

ggplot(melt(TAD_num_class), aes(x=type, y=value, fill=variable)) +
  geom_bar(position="stack", color="black", stat="identity", width = 0.5) +
  scale_fill_manual(values = c("#fb6a4a", "#74c476"), name = "TAD length") +
  coord_cartesian(ylim = c(2000, 3000))+
  theme_classic(base_size = 15) +
  theme(axis.text=element_text(size=15, colour="black")) +
  theme(axis.title.y=element_text(lineheight=5, angle=90, vjust=0,
                                  size=15, margin=margin(0,10,0,0)))+
  theme(axis.ticks.length = unit(1, "mm"),) +
  theme(axis.text.x = element_text( size=15,margin=margin(5,5,10,5,"pt"),angle = 30, hjust = 0.5,vjust = 0.5))+
  xlab("") + ylab("TAD number") + theme(legend.text = (element_text(size=15)))

```

# FigS4D
Average insulation score distribution around TAD boundaries (Â±500 kb) in control and RAD21-OE cells.
### step_01 Read boundary and insulation data
```{TAD boundary and insulation}
# WT
wt.insulation <- list()
wt.boundary <- list()
for (i in c(1:22,"X")){
  file.insulation <- paste0("/TAD_analysis/TAD_40k/WT/chr", i, 
                            "_dense.matrix--is520001--nt0--ids240001--ss160001--immean.insulation.bedGraph")
  wt.insulation[[i]] <- read.table(file.insulation,skip = 1)
  
  file.boundary <- paste0("/TAD_analysis/TAD_40k/WT/chr", i,
                          "_dense.matrix--is520001--nt0--ids240001--ss160001--immean.insulation.boundaries.bed")
  wt.boundary[[i]] <- read.table(file.boundary,skip = 1)
}
rm(file.boundary, file.insulation, i)

# RAD21-OE
OE.insulation <- list()
OE.boundary <- list()
for (i in c(1:22,"X")){
  file.insulation <- paste0("/TAD_analysis/TAD_40k/OE/chr", i, 
                            "_dense.matrix--is520001--nt0--ids240001--ss160001--immean.insulation.bedGraph")
  OE.insulation[[i]] <- read.table(file.insulation,skip = 1)
  
  file.boundary <- paste0("/TAD_analysis/TAD_40k/OE/chr", i,
                          "_dense.matrix--is520001--nt0--ids240001--ss160001--immean.insulation.boundaries.bed")
  OE.boundary[[i]] <- read.table(file.boundary,skip = 1)
}
rm(file.boundary, file.insulation, i)

```

### step_02 For each TAD boundary site, calculate the insulation score around it.
```{TAD boundary and insulation}

wt.IS_boundary <- numeric()
for ( i in c(1:22,"X")) {
  tmp <- t( apply( X = wt.boundary[[i]], 
                   MARGIN = 1, 
                   FUN = LocalIS, 
                   insulation_score = wt.insulation[[i]] ) 
  ) 
  wt.IS_boundary <- rbind(wt.IS_boundary, tmp)
}

OE.IS_boundary <- numeric()
for ( i in c(1:22,"X")) {
  tmp <- t( apply( X = OE.boundary[[i]], 
                   MARGIN = 1, 
                   FUN = LocalIS, 
                   insulation_score = OE.insulation[[i]] ) 
  ) 
  OE.IS_boundary <- rbind(OE.IS_boundary, tmp)
}

rm(tmp, i, wt.boundary, wt.insulation)
rm(tmp, i, OE.boundary, OE.insulation)

```

### step_03 Calculate median and mean of each column.
```{TAD boundary and insulation}

wt_median <- apply(wt.IS_boundary , 2, function(x) median( as.numeric(x), na.rm = T) )
OE_median <- apply(OE.IS_boundary , 2, function(x) median( as.numeric(x), na.rm = T) )

wt_mean <- apply(wt.IS_boundary , 2, function(x) mean( as.numeric(x), na.rm = T) )
OE_mean <- apply(OE.IS_boundary , 2, function(x) mean( as.numeric(x), na.rm = T) )

```

### step_04 plot Average_insulation_score_distribution_around_TAD_boundaries_in_WT_and_RAD21-OE
```{TAD boundary and insulation}

par(mar=c(4,5,4,4),lwd=3,cex=1.5)
plot( wt_mean[14:38] , type = 'l',    
      xlab = 'TAD boundary
          Genomic regions (kb)', 
      ylab = 'Mean insulation score',
      main = ' ',
      ylim = c(-0.36,0.43),
      col = "black",
      xlim = c(0, 25), 
      xaxt = "n",
      bty="l")

axis(side = 1, at = c(0.5,13,25.5), labels = c('-500','0','500'))
lines( OE_mean[14:38], col = rgb(253,13,27,maxColorValue = 255,alpha = 250))

legend(x = "topright", legend = c("WT", 
                                  "RAD21-OE"), 
       col = c("black",rgb(253,13,27,maxColorValue = 255,alpha = 250)), 
       lty = 1, bty = "n", cex=0.7)

```

# Fig4E
Saddle-analyses: Average contact frequency enrichment showing the extent of compartmentalization in control and RAD21-OE cells. Direct minus between RAD21-OE and control matrices is on the right.
```{r saddlePlot, fig.cap= "A saddle-plot: Rad21-OE cells have more inter-compartment enrichment."}

# Genome Organisation Visual Analytics (GENOVA): a software suite to perform in-depth analyses on various levels of genome organisation, using Hi-C data. 
# GENOVA facilitates the comparison between multiple datasets and supports the majority of mapping-pipelines. 
# Reference: https://github.com/robinweide/GENOVA/blob/35cb38a71ee4f38976dabe4e2d7b389d870b8c48/vignettes/GENOVA.Rmd

WT_500K <- load_contacts(signal_path = '/hic_results/matrix/WT/iced/500000/WT_500000_iced.matrix', 
                             indices_path = '/hic_results/matrix/WT/raw/500000/WT_500000_abs.bed', 
                             sample_name = "WT", 
                             colour = "black")

OE_500K <- load_contacts(signal_path = '/hic_results/matrix/OE/iced/500000/OE_500000_iced.matrix', 
                         indices_path = '/hic_results/matrix/OE/raw/500000/OE_500000_abs.bed', 
                         sample_name = "OE", 
                         colour = "red")

CS_out = compartment_score(list(WT_500K, OE_500K))

# Visualise
saddle_out = saddle(list(WT_500K, OE_500K),
                    CS_discovery = CS_out,
                    bins = 50)
visualise(saddle_out)

```

# FigS4A
Inter-chromosomal interaction ratios of each chromosome in control and RAD21-OE cells. For each chromosome, inter-interaction ratio is the percentage of inter-interaction in total interaction of this chromosome. (***P < 0.001, Wilcoxon test.)

### step_01 load hic dense matrix at 1M resolution.
Lower resolutiong matrix can reduce the computing time, and higher resolution matrix can also produce consistant conclusion.)

```{Inter-chromosomal interaction ratios}
WT_1M <- as.matrix(fread("/hic_results/matrix/WT/iced/1000000/WT_1000000_iced_dense.matrix"))
OE_1M <- as.matrix(fread("/hic_results/matrix/OE/iced/1000000/OE_1000000_iced_dense.matrix"))
```

### step_02 extract trans interaction matrix
```{Inter-chromosomal interaction ratios}

df.chr.length <- read.table("/lustre/user/liclab/zhaowx/tools/HiC-Pro_2.11.4/annotation/chrom_hg19.sizes", row.names = 1)
chr.length <- as.vector(df.chr.length$V2)
bin.size <- 1000000 # The bin size needs to be consistent with your matris resolution
bin.num <- ceiling(chr.length/bin.size)

# Establish an index for bin.size, according to the hic matrix resolution the length of each chromosome 
bin.index <- c()    
for (i in 1:23){
  bin.index[i] <- sum(bin.num[1:i])
}

# R function to extract trans interaction (this step will spend little time if using 1M resolution matrix)
trans_matrix <- function(full_dense_matrix, prefix){
  chr.index <- 1:23
  print(paste0("dim(matrix)[1] == sum(bin.num): ", identical(as.numeric(dim(full_dense_matrix)[1]),sum(bin.num))))
  
  chr.matrix <- list()
  for (i in chr.index){
    chr.matrix[[i]] <- list()
    i_start <- c(1,bin.index[-23]+1)[i]
    i_end <- bin.index[i]
    for (j in chr.index[which(chr.index==i):23]){
      j_start <- c(1,bin.index[-23]+1)[j]
      j_end <- bin.index[j]
      chr.matrix[[i]][[j]] <- full_dense_matrix[i_start:i_end,j_start:j_end]
      print(paste0(prefix,"_",i,"_",j," done!"))
    }
  }
  return(chr.matrix)
}

WT.chr_matrix <- trans_matrix(WT_1M,"WT")
OE.chr_matrix <- trans_matrix(OE_1M,"OE")

```

### step_03 calculate inter-chromosomal interaction ratios of the whole genome
```{Inter-chromosomal interaction ratios}

# R function to calculate the sum of upper-triangular interaction of a Hi-C matrix
UpperTriSum <- function ( HiC_matrix) {
  if ( is.null(HiC_matrix)) {
    return(0)
  }
  else 
    return( sum(HiC_matrix[upper.tri(HiC_matrix, diag = T) ] ) )
}


# R function to calculate the sum of trans interaction of a Hi-C upper-triangular matrix
chr.index <- 1:23
trans_sum <- function(chr.matrix){
  trans_sta <- list()
  for (i in chr.index){
    trans_sta[[i]] <- list()
    for (j in chr.index){
      if (i==j)
        trans_sta[[i]][[j]] <- UpperTriSum(chr.matrix[[i]][[j]])
      else {
        if (i < j)
          trans_sta[[i]][[j]] <- sum(chr.matrix[[i]][[j]])
        else
          trans_sta[[i]][[j]] <- trans_sta[[j]][[i]]
      }
    }
  }
  trans_sum <-  matrix(unlist(trans_sta),nrow = 23)
  return(trans_sum)
}


WT_sum <- trans_sum(WT.chr_matrix)
OE_sum <- trans_sum(OE.chr_matrix)

WT_sum_ratio <- WT_sum/UpperTriSum(WT_sum)
OE_sum_ratio <- OE_sum/UpperTriSum(OE_sum)

OE.WT <- (OE_sum_ratio-WT_sum_ratio)/WT_sum_ratio
quantile(as.vector(OE.WT))

breaksList = seq(-0.2, 0.2, by = 0.001)

# plot heat-map to visualize the change of trans interaction
pheatmap(log2(OE.WT+1),
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(length(breaksList)), 
         breaks = breaksList,
         cluster_rows = F,cluster_cols = F,
         labels_row = c(1:22,"X"),labels_col = c(1:22,"X"),display_numbers = T,number_format = "%.2f")
breaksList1 = seq(0, 0.2, by = 0.001)

# WT_sum_ratio
pheatmap(log2(WT_sum_ratio+1),
         color = colorRampPalette(brewer.pal(n = 7, name = "OrRd"))(length(breaksList1)), 
         breaks = seq(0, 0.2, by = 0.001),
         cluster_rows = F,cluster_cols = F,
         labels_row = c(1:22,"X"),labels_col = c(1:22,"X"),display_numbers = T,number_format = "%.2f")

# OE_sum_ratio
pheatmap(log2(OE_sum_ratio+1),
         color = colorRampPalette(brewer.pal(n = 7, name = "OrRd"))(length(breaksList1)), 
         breaks = seq(0, 0.2, by = 0.001),
         cluster_rows = F,cluster_cols = F,
         labels_row = c(1:22,"X"),labels_col = c(1:22,"X"),display_numbers = T,number_format = "%.2f")
```

### step_04 calculate inter-chromosomal interaction ratios of each chromosome
```{Inter-chromosomal interaction ratios}

# WT trans interaction ratio
WT.trans.ratio <- c()
for (i in chr.index){
  WT.trans.ratio[i] <- (colSums(WT_sum)[i]-WT_sum[i,i])/colSums(WT_sum)[i]
}

# OE trans interaction ratio
OE.trans.ratio <- c()
for (i in chr.index){
  OE.trans.ratio[i] <- (colSums(OE_sum)[i]-OE_sum[i,i])/colSums(OE_sum)[i]
}

trans.ratio <- cbind(WT.trans.ratio, OE.trans.ratio)
colnames(trans.ratio) <- c("WT","OE")

row.names(trans.ratio) <- c(1:22,"X")
sum(diag(OE_sum))/UpperTriSum(OE_sum)
sum(diag(WT_sum))/UpperTriSum(WT_sum)

# WT vs. OE
WT.OE.trans.ratio <- cbind(WT.trans.ratio, OE.trans.ratio)
colnames(WT.OE.trans.ratio) <- c("WT","OE")
row.names(WT.OE.trans.ratio) <- c(1:22,"X")

# Statistical hypothesis testing (paired Wilcoxon test is suitable )

## Shapiro-Wilk normality test 
shapiro.test(WT.OE.trans.ratio[,1]) # W = 0.9654, p-value = 0.5803
shapiro.test(WT.OE.trans.ratio[,2]) # W = 0.95759, p-value = 0.4165

## F test to compare two variances
WT.OE.trans.ratio.m <- melt(WT.OE.trans.ratio)
var.test(value ~ Var2, WT.OE.trans.ratio.m) # ratio of variances 1.17092 

## Wilcoxon test
wilcox.test(WT.OE.trans.ratio[,1], WT.OE.trans.ratio[,2], paired = T) # p-value = 0.0000002384

# write.table(WT.OE.trans.ratio, file="trans.ratio.WT.OE.txt", row.names = FALSE, col.names = TRUE)

```

### step_05 boxplot
```{Inter-chromosomal interaction ratios}

ggplot(WT.OE.trans.ratio.m, aes(x = Var2, y = value)) + 
  geom_boxplot(aes(fill=Var2), outlier.size = 0,outlier.shape = NA)+
  stat_boxplot(geom = "errorbar", width=0.4) + 
  geom_boxplot(aes(x = Var2, y = value, fill=factor(Var2)), color="black", outlier.size = 0, outlier.shape = NA) +
  labs(x = " ", y = " inter-chromosomal
 interaction ratios (%)", title = "Trans-interaction ratios")+
  scale_fill_manual(values = c("grey","red"))+
  theme_classic()+
  theme(axis.text.x = element_text(size = 16), 
        axis.text.y = element_text(size = 16),
        axis.title.y = element_text(size = 16))+
  geom_segment(aes(x=1, y=0.56, xend=2, yend=0.56))+ 
  geom_text(x=1.5, y=0.56, label="***", size= 5 )

```


# Reference

- Anders, S., Pyl, P.T., and Huber, W. (2015). HTSeq--a Python framework to work with high-throughput sequencing data. Bioinformatics 31, 166-169.
- Crane, E., Bian, Q., McCord, R.P., Lajoie, B.R., Wheeler, B.S., Ralston, E.J., Uzawa, S., Dekker, J., and Meyer, B.J. (2015). Condensin-driven remodelling of X chromosome topology during dosage compensation. Nature 523, 240-U299.
- Chang, L., Li, M., Shao, S., Li, C., Ai, S., Xue, B., Hou, Y., Zhang, Y., Li, R., Fan, X., et al. (2022). Nuclear peripheral chromatin-lamin B1 interaction is required for global integrity of chromatin architecture and dynamics in human cells. Protein Cell 13, 258-280.
- Servant, N., Lajoie, B.R., Nora, E.P., Giorgetti, L., Chen, C.J., Heard, E., Dekker, J., and Barillot, E. (2012). HiTC: exploration of high-throughput 'C' experiments. Bioinformatics 28, 2843-2844.
- Servant, N., Varoquaux, N., Lajoie, B.R., Viara, E., Chen, C.J., Vert, J.P., Heard, E., Dekker, J., and Barillot, E. (2015). HiC-Pro: an optimized and flexible pipeline for Hi-C data processing. Genome Biology 16.
- van der Weide, R.H., van den Brand, T., Haarhuis, J.H.I., Teunissen, H., Rowland, B.D., and de Wit, E. (2021). Hi-C analyses with GENOVA: a case study with cohesin variants. NAR Genom Bioinform 3, lqab040.





